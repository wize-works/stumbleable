name: Build and Deploy to AKS

on:
    push:
        branches:
            - main
            - develop
    pull_request:
        branches:
            - main
    workflow_dispatch:

env:
    ACR_NAME: ${{ secrets.ACR_NAME }}
    AKS_CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}
    AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}
    NAMESPACE: stumbleable

jobs:
    # Build and push Docker images
    build-and-push:
        name: Build and Push Images
        runs-on: ubuntu-latest
        strategy:
            matrix:
                service:
                    - name: ui
                      context: ./ui/portal
                      dockerfile: ./ui/portal/Dockerfile
                    - name: discovery
                      context: ./apis/discovery-service
                      dockerfile: ./apis/discovery-service/Dockerfile
                    - name: interaction
                      context: ./apis/interaction-service
                      dockerfile: ./apis/interaction-service/Dockerfile
                    - name: user
                      context: ./apis/user-service
                      dockerfile: ./apis/user-service/Dockerfile
                    - name: crawler
                      context: ./apis/crawler-service
                      dockerfile: ./apis/crawler-service/Dockerfile
                    - name: moderation
                      context: ./apis/moderation-service
                      dockerfile: ./apis/moderation-service/Dockerfile
                    - name: email
                      context: ./apis/email-service
                      dockerfile: ./apis/email-service/Dockerfile
                    - name: scheduler
                      context: ./apis/scheduler-service
                      dockerfile: ./apis/scheduler-service/Dockerfile

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            - name: Azure Login
              uses: azure/login@v1
              with:
                  creds: ${{ secrets.AZURE_CREDENTIALS }}

            - name: Log in to Azure Container Registry
              run: |
                  az acr login --name ${{ env.ACR_NAME }}

            - name: Extract metadata (tags, labels)
              id: meta
              uses: docker/metadata-action@v5
              with:
                  images: ${{ env.ACR_NAME }}.azurecr.io/stumbleable-${{ matrix.service.name }}
                  tags: |
                      type=ref,event=branch
                      type=ref,event=pr
                      type=sha,prefix={{branch}}-
                      type=raw,value=latest,enable={{is_default_branch}}

            - name: Build and push Docker image
              uses: docker/build-push-action@v5
              with:
                  context: ${{ matrix.service.context }}
                  file: ${{ matrix.service.dockerfile }}
                  push: true
                  tags: ${{ steps.meta.outputs.tags }}
                  labels: ${{ steps.meta.outputs.labels }}
                  cache-from: type=registry,ref=${{ env.ACR_NAME }}.azurecr.io/stumbleable-${{ matrix.service.name }}:buildcache
                  cache-to: type=registry,ref=${{ env.ACR_NAME }}.azurecr.io/stumbleable-${{ matrix.service.name }}:buildcache,mode=max
                  build-args: |
                      NODE_ENV=production
                      NEXT_PUBLIC_DISCOVERY_API_URL=https://api.stumbleable.com/discovery
                      NEXT_PUBLIC_INTERACTION_API_URL=https://api.stumbleable.com/interaction
                      NEXT_PUBLIC_USER_API_URL=https://api.stumbleable.com/user
                      NEXT_PUBLIC_CRAWLER_API_URL=https://api.stumbleable.com/crawler
                      NEXT_PUBLIC_MODERATION_API_URL=https://api.stumbleable.com/moderation
                      NEXT_PUBLIC_EMAIL_API_URL=https://api.stumbleable.com/email
                      NEXT_PUBLIC_SCHEDULER_API_URL=https://api.stumbleable.com/scheduler
                      NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}

    # Deploy to AKS
    deploy:
        name: Deploy to AKS
        runs-on: ubuntu-latest
        needs: build-and-push
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Azure Login
              uses: azure/login@v1
              with:
                  creds: ${{ secrets.AZURE_CREDENTIALS }}

            - name: Install kubelogin
              run: |
                  # Download and install kubelogin for AAD-enabled AKS clusters
                  curl -LO https://github.com/Azure/kubelogin/releases/download/v0.0.32/kubelogin-linux-amd64.zip
                  unzip kubelogin-linux-amd64.zip
                  sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
                  sudo chmod +x /usr/local/bin/kubelogin
                  kubelogin --version

            - name: Set AKS context
              uses: azure/aks-set-context@v3
              with:
                  resource-group: ${{ env.AKS_RESOURCE_GROUP }}
                  cluster-name: ${{ env.AKS_CLUSTER_NAME }}

            - name: Convert kubeconfig to use kubelogin
              run: |
                  kubelogin convert-kubeconfig -l azurecli

            - name: Create namespace if not exists
              run: |
                  kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

            - name: Create secrets from GitHub Secrets
              run: |
                  kubectl create secret generic stumbleable-secrets \
                    --namespace=${{ env.NAMESPACE }} \
                    --from-literal=SUPABASE_URL="${{ secrets.SUPABASE_URL }}" \
                    --from-literal=SUPABASE_SERVICE_KEY="${{ secrets.SUPABASE_SERVICE_KEY }}" \
                    --from-literal=NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}" \
                    --from-literal=CLERK_PUBLISHABLE_KEY="${{ secrets.CLERK_PUBLISHABLE_KEY }}" \
                    --from-literal=CLERK_SECRET_KEY="${{ secrets.CLERK_SECRET_KEY }}" \
                    --from-literal=CLERK_WEBHOOK_SECRET="${{ secrets.CLERK_WEBHOOK_SECRET }}" \
                    --from-literal=RESEND_API_KEY="${{ secrets.RESEND_API_KEY }}" \
                    --dry-run=client -o yaml | kubectl apply -f -

            - name: Set image tag
              id: image-tag
              run: |
                  if [ "${{ github.ref }}" == "refs/heads/main" ]; then
                    echo "IMAGE_TAG=latest" >> $GITHUB_OUTPUT
                  else
                    echo "IMAGE_TAG=${{ github.ref_name }}-${{ github.sha }}" >> $GITHUB_OUTPUT
                  fi
                  # Generate unique deployment timestamp to force rolling update
                  echo "DEPLOYMENT_TIMESTAMP=$(date +%s)" >> $GITHUB_OUTPUT

            - name: Deploy ConfigMap
              run: |
                  envsubst < k8s/base/configmap.yaml | kubectl apply -f -
              env:
                  ACR_NAME: ${{ env.ACR_NAME }}
                  IMAGE_TAG: ${{ steps.image-tag.outputs.IMAGE_TAG }}
                  DEPLOYMENT_TIMESTAMP: ${{ steps.image-tag.outputs.DEPLOYMENT_TIMESTAMP }}

            - name: Deploy services
              run: |
                  for file in k8s/base/*.yaml; do
                    if [[ "$file" != *"secrets.yaml.template"* ]]; then
                      envsubst < "$file" | kubectl apply -f -
                    fi
                  done
              env:
                  ACR_NAME: ${{ env.ACR_NAME }}
                  IMAGE_TAG: ${{ steps.image-tag.outputs.IMAGE_TAG }}
                  DEPLOYMENT_TIMESTAMP: ${{ steps.image-tag.outputs.DEPLOYMENT_TIMESTAMP }}

            - name: Wait for deployments
              run: |
                  kubectl rollout status deployment/ui-portal -n ${{ env.NAMESPACE }} --timeout=5m
                  kubectl rollout status deployment/discovery-service -n ${{ env.NAMESPACE }} --timeout=5m
                  kubectl rollout status deployment/interaction-service -n ${{ env.NAMESPACE }} --timeout=5m
                  kubectl rollout status deployment/user-service -n ${{ env.NAMESPACE }} --timeout=5m
                  kubectl rollout status deployment/crawler-service -n ${{ env.NAMESPACE }} --timeout=5m
                  kubectl rollout status deployment/moderation-service -n ${{ env.NAMESPACE }} --timeout=5m
                  kubectl rollout status deployment/email-service -n ${{ env.NAMESPACE }} --timeout=5m
                  kubectl rollout status deployment/scheduler-service -n ${{ env.NAMESPACE }} --timeout=5m

            - name: Verify deployments
              run: |
                  kubectl get pods -n ${{ env.NAMESPACE }}
                  kubectl get services -n ${{ env.NAMESPACE }}
                  kubectl get ingress -n ${{ env.NAMESPACE }}

            - name: Run smoke tests
              run: |
                  # Wait for services to be ready
                  sleep 30

                  # Test UI health
                  kubectl run curl-test --image=curlimages/curl:latest --restart=Never -n ${{ env.NAMESPACE }} -- \
                    curl -f http://ui-portal:3000/api/health || true

                  # Test API health endpoints
                  kubectl run curl-test-discovery --image=curlimages/curl:latest --restart=Never -n ${{ env.NAMESPACE }} -- \
                    curl -f http://discovery-service:7001/health || true

                  kubectl run curl-test-interaction --image=curlimages/curl:latest --restart=Never -n ${{ env.NAMESPACE }} -- \
                    curl -f http://interaction-service:7002/health || true

                  kubectl run curl-test-user --image=curlimages/curl:latest --restart=Never -n ${{ env.NAMESPACE }} -- \
                    curl -f http://user-service:7003/health || true

                  kubectl run curl-test-moderation --image=curlimages/curl:latest --restart=Never -n ${{ env.NAMESPACE }} -- \
                    curl -f http://moderation-service:7005/health || true

                  kubectl run curl-test-email --image=curlimages/curl:latest --restart=Never -n ${{ env.NAMESPACE }} -- \
                    curl -f http://email-service:7006/health || true

                  kubectl run curl-test-scheduler --image=curlimages/curl:latest --restart=Never -n ${{ env.NAMESPACE }} -- \
                    curl -f http://scheduler-service:7007/health || true

                  # Cleanup test pods
                  kubectl delete pod curl-test curl-test-discovery curl-test-interaction curl-test-user curl-test-moderation curl-test-email curl-test-scheduler -n ${{ env.NAMESPACE }} --ignore-not-found=true

    # Notify on completion
    notify:
        name: Notify Deployment Status
        runs-on: ubuntu-latest
        needs: [build-and-push, deploy]
        if: always()

        steps:
            - name: Deployment Success
              if: ${{ needs.deploy.result == 'success' }}
              run: |
                  echo "✅ Deployment to AKS successful!"
                  echo "Environment: ${{ github.ref_name }}"
                  echo "Commit: ${{ github.sha }}"

            - name: Deployment Failed
              if: ${{ needs.deploy.result == 'failure' }}
              run: |
                  echo "❌ Deployment to AKS failed!"
                  exit 1
